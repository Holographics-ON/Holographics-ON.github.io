<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
        <link href="main.css" rel="stylesheet">
        <title>Background glitch </title>
    </head>
    <body>
        <!-- Canvas defaults size is 300 x 150 px-->
        <!-- Canvas default display mode is inline (has whitespaces) -->
         <canvas id="c"></canvas>
    </body>
    <script type="module">
    import * as THREE from './js/threejs/r112/build/three.module.js';

    function init() {
        const canvas = document.querySelector('#c');

        // Must specify alpha paramter to use
        const renderer = new THREE.WebGLRenderer({
            canvas,
            alpha:true,
            premultipliedAlpha: false, 
        });

        const fov = 75;
        const aspect = 2; //canvas default aspect
        const near = 0.1;
        const far = 5;
        const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
        camera.position.z = 3;
        
        const scene = new THREE.Scene();

        {
        const color = 0xFFFFFF;
        const intensity = 1;
        const light = new THREE.DirectionalLight(color, intensity) ;
        light.position.set(-1, 2, 4);
        scene.add(light);
        }

        const radius = 1;
        const widthSegments = 25;
        const heightSegments = 5;
        const geometry = new THREE.SphereGeometry(radius, widthSegments, heightSegments);

        // Modify opacity in material
        const material = new THREE.MeshPhongMaterial({
            color: 0x9932cc,
            opacity: 0.7,
            wireframe: false,
            emissive: 0x4682b4,
            emissiveIntensity : 0.8,
            });

        const sphere = new THREE.Mesh(geometry, material);
        scene.add(sphere);

            
        function resizeRendererToDisplaySize(renderer) {
            //Only changes the display size if it returns true
            const canvas = renderer.domElement;
            const pixelRatio = window.devicePixelRatio;
            const width = canvas.clientWidth * pixelRatio | 0;
            const height = canvas.clientHeight * pixelRatio | 0;
            const needResize = canvas.width !== width || canvas.height !== height;
            if (needResize) {
                // False needed as it stops the default sets of canvas CSS's size
                renderer.setSize(width, height, false);
            }
            // Returns if truthy the width or height has diff values
            return needResize;

        }

        function animate(time) {
            //convert time to seconds
            time *= 0.00015; 
            
            //Match the aspect of the camera to the aspect of canvas display size
            if(resizeRendererToDisplaySize(renderer)) {
                const canvas = renderer.domElement;
                camera.aspect = canvas.clientWidth/ canvas.clientHeight;
                camera.updateProjectionMatrix();
            }

            sphere.rotation.x = time;
            sphere.rotation.y = time * 2;

            renderer.render(scene, camera);
        
            requestAnimationFrame(animate);
        }
        requestAnimationFrame(animate);
    }

    init();

    </script>
</html>
